import '../entities/project_application_entity/project_application_entity.dart';
import '../repositories/business_owner_repository.dart';

class CreateProjectApplicationUseCase {
  final ProjectApplicationRepository repository;

  CreateProjectApplicationUseCase(this.repository);

  Future<ProjectApplication> call(CreateProjectApplicationParams params) async {
    final application = ProjectApplication(
      id: '', // Will be generated by repository
      businessOwnerId: params.businessOwnerId,
      projectName: params.projectName,
      projectDescription: params.projectDescription,
      website: params.website,
      contractAddress: params.contractAddress,
      tokenSymbol: params.tokenSymbol,
      tokenName: params.tokenName,
      status: ApplicationStatus.draft,
      submittedAt: DateTime.now(),
      applicationData: params.applicationData,
      checklist: VerificationChecklist(
        teamVerificationComplete: false,
        smartContractAuditComplete: false,
        liquidityLockVerified: false,
        tokenomicsVerified: false,
        financialAuditComplete: false,
        technicalReviewComplete: false,
        marketingPlanApproved: false,
        communityGuidelinesAccepted: false,
      ),
    );

    return await repository.createApplication(application);
  }
}

class GetProjectApplicationUseCase {
  final ProjectApplicationRepository repository;

  GetProjectApplicationUseCase(this.repository);

  Future<ProjectApplication> call(String id) async {
    return await repository.getApplicationById(id);
  }
}

class GetApplicationsByBusinessOwnerUseCase {
  final ProjectApplicationRepository repository;

  GetApplicationsByBusinessOwnerUseCase(this.repository);

  Future<List<ProjectApplication>> call(String businessOwnerId) async {
    return await repository.getApplicationsByBusinessOwner(businessOwnerId);
  }
}

class UpdateProjectApplicationUseCase {
  final ProjectApplicationRepository repository;

  UpdateProjectApplicationUseCase(this.repository);

  Future<ProjectApplication> call(ProjectApplication application) async {
    return await repository.updateApplication(application);
  }
}

class SubmitProjectApplicationUseCase {
  final ProjectApplicationRepository repository;

  SubmitProjectApplicationUseCase(this.repository);

  Future<ProjectApplication> call(String applicationId) async {
    final application = await repository.getApplicationById(applicationId);

    if (!application.checklist.isComplete) {
      throw Exception('Application checklist is not complete');
    }

    final submittedApplication = application.copyWith(
      status: ApplicationStatus.submitted,
    );

    return await repository.updateApplication(submittedApplication);
  }
}

class GetApplicationsByStatusUseCase {
  final ProjectApplicationRepository repository;

  GetApplicationsByStatusUseCase(this.repository);

  Future<List<ProjectApplication>> call(ApplicationStatus status) async {
    return await repository.getApplicationsByStatus(status);
  }
}

class GetPendingApplicationsUseCase {
  final ProjectApplicationRepository repository;

  GetPendingApplicationsUseCase(this.repository);

  Future<List<ProjectApplication>> call() async {
    return await repository.getPendingApplications();
  }
}

class CreateProjectApplicationParams {
  final String businessOwnerId;
  final String projectName;
  final String projectDescription;
  final String website;
  final String contractAddress;
  final String tokenSymbol;
  final String tokenName;
  final ProjectApplicationData applicationData;

  const CreateProjectApplicationParams({
    required this.businessOwnerId,
    required this.projectName,
    required this.projectDescription,
    required this.website,
    required this.contractAddress,
    required this.tokenSymbol,
    required this.tokenName,
    required this.applicationData,
  });
}
