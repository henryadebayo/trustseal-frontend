import '../entities/admin_entity.dart';
import '../repositories/admin_repository.dart';
import '../../../business_owners/data/models/project_application_model.dart';
import '../../../business_owners/domain/entities/project_application_entity/project_application_entity.dart';

/// Use case for managing application reviews
class ReviewApplicationUseCase {
  final AdminRepository _repository;

  ReviewApplicationUseCase(this._repository);

  Future<String> createReview({
    required String applicationId,
    required String adminId,
    required ReviewStatus status,
    String? reviewNotes,
    Map<String, bool>? checklistResults,
    List<String>? requiredChanges,
    int? verificationScore,
  }) async {
    final review = ApplicationReview(
      id: '', // Will be generated by repository
      applicationId: applicationId,
      adminId: adminId,
      status: status,
      reviewedAt: DateTime.now(),
      reviewNotes: reviewNotes,
      checklistResults: checklistResults ?? {},
      requiredChanges: requiredChanges ?? [],
      verificationScore: verificationScore ?? 0,
    );

    return await _repository.createReview(review);
  }

  Future<void> updateReview(ApplicationReview review) async {
    await _repository.updateReview(review);
  }

  Future<List<ApplicationReview>> getReviewsForApplication(
    String applicationId,
  ) async {
    return await _repository.getReviewsByApplicationId(applicationId);
  }
}

/// Use case for admin dashboard operations
class AdminDashboardUseCase {
  final AdminRepository _repository;

  AdminDashboardUseCase(this._repository);

  Future<AdminDashboardStats> getDashboardStats() async {
    return await _repository.getDashboardStats();
  }

  Future<List<ProjectApplicationModel>> getPendingApplications() async {
    return await _repository.getApplicationsByStatus(
      ApplicationStatus.submitted,
    );
  }

  Future<List<ProjectApplicationModel>> getUnderReviewApplications() async {
    return await _repository.getApplicationsByStatus(
      ApplicationStatus.underReview,
    );
  }

  Future<List<ProjectApplicationModel>> getApplicationsForReview() async {
    return await _repository.getApplicationsForReview();
  }
}

/// Use case for audit logging
class AuditLogUseCase {
  final AdminRepository _repository;

  AuditLogUseCase(this._repository);

  Future<void> logAdminAction({
    required String adminId,
    required String action,
    required String targetType,
    required String targetId,
    Map<String, dynamic>? metadata,
    String? ipAddress,
  }) async {
    final auditEntry = AuditLogEntry(
      id: '', // Will be generated
      adminId: adminId,
      action: action,
      targetType: targetType,
      targetId: targetId,
      metadata: metadata,
      timestamp: DateTime.now(),
      ipAddress: ipAddress ?? 'unknown',
    );

    await _repository.logAuditEvent(auditEntry);
  }

  Future<List<AuditLogEntry>> getAuditLogs({
    String? adminId,
    String? action,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    return await _repository.getAuditLogs(
      adminId: adminId,
      action: action,
      startDate: startDate,
      endDate: endDate,
    );
  }
}

/// Use case for admin management
class AdminManagementUseCase {
  final AdminRepository _repository;

  AdminManagementUseCase(this._repository);

  Future<List<Admin>> getAllAdmins() async {
    return await _repository.getAllAdmins();
  }

  Future<Admin?> getAdminById(String id) async {
    return await _repository.getAdminById(id);
  }

  Future<String> createAdmin({
    required String name,
    required String email,
    required AdminRole role,
  }) async {
    final admin = Admin(
      id: '', // Will be generated
      name: name,
      email: email,
      role: role,
      createdAt: DateTime.now(),
      lastLoginAt: DateTime.now(),
      isActive: true,
    );

    return await _repository.createAdmin(admin);
  }

  Future<void> updateAdmin(Admin admin) async {
    await _repository.updateAdmin(admin);
  }

  Future<void> deactivateAdmin(String adminId) async {
    final admin = await _repository.getAdminById(adminId);
    if (admin != null) {
      final updatedAdmin = Admin(
        id: admin.id,
        name: admin.name,
        email: admin.email,
        role: admin.role,
        createdAt: admin.createdAt,
        lastLoginAt: admin.lastLoginAt,
        isActive: false,
      );
      await _repository.updateAdmin(updatedAdmin);
    }
  }
}
